#!/usr/bin/env python3
#
# Tool for converting images into PicoSystem API-friendly CPP headers.
# By default, images are loaded as const (read-only) buffers that can be
# set as spritesheets in the API and remain in flash rather than taking up RAM.
#
# Copyright (c) 2022 Pete Favelle <picosystem@ahnlak.com>
# This file is distributed under the MIT License; see LICENSE for details.

from PIL import Image
import sys
import pathlib
import math
import argparse


def source_stanza(name, ostream):
  """Writes a comment at the top of each generated source file"""
  ostream.write(f'/*\n * Image data for {name}\n')
  ostream.write(' * This file was automatically generated by pst_image.py\n')
  ostream.write(' * DO NOT EDIT THIS FILE!\n')
  ostream.write(' */\n')
  ostream.write('#pragma once\n')


def source_header(name, ostream):
  """Writes out the main variable definition, based on image name"""

  # So, open up the array, with options as required
  ostream.write(f'const picosystem::color_t {name}_data[] = {{\n')


def source_footer(name, width, height, ostream):
  """Writes the end of the variable definition and, if required, the buffer"""

  # So, close the array first
  ostream.write('};\n')

  # Then, if required, a buffer definition too
  ostream.write(f'picosystem::buffer_t {name}_buffer')
  ostream.write(f'{{.w = {width}, .h = {height}, ')
  ostream.write(f'.data = (picosystem::color_t *){name}_data}};\n')


def rgba_bytes(image, ostream):
  """Writes the image data to the output stream, as hex values per pixel"""

  # Keep a count of bytes, to keep the generated line lengths sensible
  span = 0

  # Loop through the entire image, one pixel at a time
  for row in range(0, image.height):
    for col in range(0, image.width):
      # Break the pixel into RGBA components
      (r,g,b,a) = image.getpixel((col, row))

      # Convert these values down to 4 bits a piece
      br = min(15, math.ceil(r/16))
      bg = min(15, math.ceil(g/16))
      bb = min(15, math.ceil(b/16))
      ba = min(15, math.ceil(a/16))

      # Merge them down into a single 16-bit value
      pixel = (bg<<12)|(bb<<8)|(ba<<4)|br

      # And emit this is a value into the output
      ostream.write(f'0x{pixel:04x}, ')

      # Check if we've reached a line boundary
      if span >= 7:
        span = 0
        ostream.write('\n')
      else:
        span += 1


def process_image(filename):
  """Converts a single image file, applying any global options"""

  # Work out the source and target pathnames
  source_path = pathlib.Path(filename)
  target_path = source_path.with_suffix('.hpp')

  # Try to load the image; if we can't do that, we can't do anything
  try:
    source_image = Image.open(source_path).convert('RGBA')
  except Exception as e:
    print(f'Failed to open {filename}')
    print(e)
    return

  # Open up the target for writing to
  target_file = open(target_path, 'w')

  # Generate the stanza
  source_stanza(source_path.name, target_file)

  # Apply the appropriate data name
  source_header(source_path.stem, target_file)

  # Generate the data itself
  rgba_bytes(source_image, target_file)

  # And then the footer stuff
  source_footer(source_path.stem, source_image.width, source_image.height, target_file)

  # Good; close up the file and report what we've done
  target_file.close()
  print(f'Image {filename} data written to {target_path}\n')


def main() -> int:
  """Convert the provided image(s) into appropriate C(++) data"""

  # Make sense of the command line.
  parser = argparse.ArgumentParser()
  parser.add_argument("image", help="The image file to be converted", nargs="+")
  parser.add_argument("-q", "--quiet", 
                      help="Does not print image details on conversion",
                      action="store_true")
  args = parser.parse_args()

  # Work through each image, one at a time
  for image in args.image:
    process_image(image)

  # All done
  return 0


if __name__ == '__main__':
  sys.exit(main())
